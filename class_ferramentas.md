# Classificação das Ferramentas de Injeção de Falhas

Definições baseadas em [A Survey on Fault Injection Techniques](https://www.ccis2k.org/iajit/PDF/vol.1,no.2/04-Hissam.pdf)

**Hardware-Based Fault Injection**: Injeção de falhas baseada em hardware: É realizada no nível físico, perturbando o hardware com parâmetros do ambiente (radiação de íons pesados, interferências eletromagnéticas, etc.), injetando afundamentos de tensão nos trilhos de alimentação do hardware (distúrbios na fonte de alimentação), laser injeção de falhas ou modificação do valor dos pinos do circuito.

**Software-Based Fault Injection**: Injeção de falhas baseada em software (injeção de falhas implementada por software): O objetivo desta técnica consiste em reproduzir em nível de software os erros que teriam sido produzidos se ocorressem falhas no hardware.

**Simulation-Based Fault Injection**: Injeção de falhas baseada em simulação: Consiste em injetar as falhas em modelos de alto nível (na maioria das vezes, modelos VHDL). Permite avaliar antecipadamente a confiabilidade do sistema quando apenas um modelo do sistema está disponível. Em seguida, aborda diferentes níveis de abstração usando linguagens de descrição distintas. Deve ser fornecido um ambiente coerente para favorecer a interoperabilidade entre os sucessivos níveis de abstração e para integrar a validação no processo de design.

**Emulation-Based Fault Injection**: Injeção de falhas baseada em emulação: Esta técnica tem sido apresentada como uma solução alternativa para reduzir o tempo gasto durante campanhas de injeção de falhas baseadas em simulação. É baseado na exploração do uso de Field Programmable Gate Arrays (FPGAs) para acelerar a simulação de falhas e explora FPGAs para emulação de circuito eficaz. Esta técnica pode permitir ao projetista estudar o comportamento real do circuito no ambiente de aplicação, levando em consideração as interações em tempo real. Entretanto, quando um emulador é usado, a descrição inicial do VHDL deve ser sintetizável

**Hybrid Fault Injection**: Esta abordagem combina injeção de falhas implementada por software e monitoramento de hardware




|  Ferramenta   |                Tipo                | Descrição                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| :-----------: | :--------------------------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|   **AFEX**    |  *Software-Based Fault Injection*  | - O AFEX é um sistema de teste paralelo baseado em cluster. <br> <br> - Ele usa um algoritmo baseado em feedback guiado por aptidão para encontrar falhas de alto impacto em espaços com estrutura desconhecida. <br> <br> - O sistema aprende dinamicamente a estrutura do espaço com base em falhas injetadas anteriormente. <br> <br> - O objetivo é alcançar um alvo específico, como um determinado nível de cobertura de código, limite no nível de impacto das falhas, ou limite de tempo <br> <br> - Após a conclusão, o AFEX analisa as falhas injetadas, as agrupa, categoriza e classifica por gravidade para facilitar a análise dos desenvolvedores. <br> <br> - O sistema pode alavancar conhecimento específico de domínio, quando humanos têm e podem codificá-lo adequadamente, influenciando a velocidade e qualidade da busca.                                                                                                                                                                                                                                                                                                                                                                                                                 |
|   **FIAT**    |      *Hybrid Fault Injection*      | - O ambiente FIAT localiza automaticamente código-objeto ou dados designados de sua designação de código-fonte e toma medidas contra eles. <br> <br> - Pode injetar código e dados do aplicativo do usuário e pode injetar dados em mensagens (corrompidas, perdidas, atrasadas), tarefas (atrasadas, encerramento anormal) e temporizadores. <br> <br> - Versões subsequentes estenderão esses recursos de injeção de falhas aos sistemas operacionais e permitirão a injeção de falhas de hardware sob o controle da FIAT. <br> <br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|   **FTAPE**   |  *Software-Based Fault Injection*  | - Pode injetar falhas em registros acessíveis ao usuário em módulos de CPU, locais de memória e subsistema de disco. <br> <br> - As falhas são injetadas como bitflips para emular erros como resultado de falhas. <br> <br> - Falhas no sistema de disco são injetadas executando uma rotina no código do driver que emula erros de E/S (erro de barramento e erro de timer, por exemplo). <br> <br> - Os drivers de injeção de falhas adicionados ao sistema operacional injetam as falhas, portanto, nenhum hardware adicional ou modificação do código do aplicativo é necessário. <br> <br> - Um gerador de carga de trabalho sintético cria uma carga de trabalho contendo quantidades especificadas de CPU, memória e atividade de E/S. <br> <br> - As falhas são injetadas com uma estratégia que considera as características da carga de trabalho no momento da injeção (quais componentes estão enfrentando a maior quantidade de carga de trabalho atividade, por exemplo).                                                                                                                                                                                                                                                                           |
| **Xception**  |  *Software-Based Fault Injection*  | - Usa as exceções dos próprios processadores para acionar as falhas, sem requerer nenhuma modificação no software aplicativo ou inserção de armadilhas de software. <br> <br> - Monitora detalhadamente a ativação das falhas e seu impacto no comportamento do sistema alvo. <br> <br> - Fornece um conjunto abrangente de gatilhos de falhas, incluindo gatilhos espaciais e temporais e gatilhos relacionados à manipulação de dados na memória. <br> <br> - As falhas injetadas pelo Xception podem afetar qualquer processo em execução no sistema de destino, incluindo o sistema operacional. <br> <br> - Conjuntos de falhas podem ser definidos pelo usuário de acordo com vários critérios, incluindo a emulação de falhas em unidades funcionais específicas do processador alvo. <br> <br>  - As falhas do Xception são acionadas pelo acesso a endereços específicos. <br> <br> - Usa uma máscara de falha ao injetar uma falha em um local do sistema, comparando-a com a memória/registro/dados e alterando os bits definidos como um na máscara usando operações em nível de bit, como:  Stuck-at-zero, stuck-atone, bit-flip and bridging.                                                                                                       |
|  **Ferrari**  |  *Software-Based Fault Injection*  | - Usa armadilhas de software para injetar falhas de CPU, memória e barramento. <br> <br> - Consiste em quatro componentes: o inicializador e ativador, as informações do usuário, o injetor de falhas e erros, e o coletor e analisador de dados. <br> <br> - O injetor de falha e erro usa armadilhas de software e rotinas de manipulação de armadilhas acionadas pelo contador do programa ou por um temporizador. <br> <br> - Quando as armadilhas são acionadas, as rotinas de manipulação de armadilhas injetam falhas nos locais de falha específicos, normalmente alterando o conteúdo dos registros selecionados ou locais de memória para emular corrupções de dados reais. <br> <br> - As falhas injetadas podem ser permanentes ou transitórias, resultando em erro de linha de endereço, erro de linha de dados e erro de bit de condição. <br> <br>                                                                                                                                                                                                                                                                                                                                                                                                 |
|  **Mafalda**  |  *Software-Based Fault Injection*  | - O objetivo principal do MAFALDA é analisar o comportamento de um microkernel na presença de falhas, incluindo a robustez da interface em relação a falhas externas, cobertura de detecção de erros dos mecanismos internos de detecção de erros, canais de propagação de erros entre componentes internos do microkernel e o impacto de defeitos nas camadas superiores. <br> <br> - Baseia-se na ideia de uma carga de trabalho modular, combinando com a arquitetura componenteizada de um microkernel, onde os módulos internos fornecem uma interface para o nível do aplicativo como um conjunto de operações do kernel, chamadas primitivas. <br> <br> - Cada processo de carga de trabalho implementa uma aplicação simples usando quase todas as primitivas disponíveis de uma determinada classe funcional, exercitando assim as funcionalidades correspondentes do microkernel. <br> <br> - A corrupção dos parâmetros de entrada é usada para avaliar as propriedades de robustez inerentes à interface do microkernel, consistindo em corromper um parâmetro selecionado antes de sua entrega à interface do microkernel, interpretada como consequência da propagação de um erro do nível aplicativo para o nível executivo. <br> <br>             |
| **Mefisto-C** | *Simulation-Based Fault Injection* | - MEFISTO-C utiliza o simulador VHDL Ideal Vantage para injetar falhas através de comandos do simulador em variáveis e sinais definidos no modelo VHDL. <br> <br> - Oferece ao usuário uma variedade de modelos de falhas predefinidos e recursos para configurar e conduzir automaticamente campanhas de injeção de falhas em uma rede de estações de trabalho UNIX. <br> <br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|  **PREFAIL**  |  *Hardware-Based Fault Injection*  | - Permite aos testadores escrever políticas para expressar combinações de múltiplas falhas desejadas, evitando a necessidade de explorar todas as combinações possíveis. <br> <br> - Separação do PREFAIL em duas partes: o mecanismo de injeção de falha, responsável por realizar a injeção de falhas em diferentes pontos de execução do sistema em teste, e o driver de injeção de falha, onde os testadores podem escrever políticas para "dirigir" o motor. <br> <br> - Fornecimento de abstrações adequadas de falhas, pontos de execução onde as falhas podem ser injetadas e perfis de execuções onde as falhas são injetadas. <br> <br> - As abstrações fornecidas podem ser usadas pelos testadores para escrever facilmente uma ampla variedade de políticas de remoção                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|   **RIFLE**   |  *Hardware-Based Fault Injection*  | - Conjuntos de falhas F são gerados considerando o universo do experimento (U), composto pelo modelo do sistema alvo, os benchmarks e o modelo de falhas no nível do pino. <br> <br> - A injeção destas falhas produz resultados e, dependendo da técnica de tolerância a falhas em avaliação, a análise adequada será realizada sobre estes resultados. <br> <br> - Como consequência dos resultados/análises, novos conjuntos de falhas ou alterações no universo U podem ser necessários. <br> <br> - Cada falta é definida por um conjunto de atributos como duração da falta, linhas afetadas, tipo de falta e condições específicas que desencadeiam a injeção da falta. <br> <br> - Um conjunto de falhas F definido a partir de um determinado universo U só é válido para este universo. <br> <br> - Duas falhas diferentes devem ser descritas por dois conjuntos diferentes de atributos, a fim de obter injeção repetitiva de falhas, garantindo que a injeção de F nas condições definidas por U produza sempre os mesmos resultados. <br> <br> - Mudanças no universo U, por exemplo mudanças nos benchmarks, farão com que a injeção de F produza resultados diferentes porque as falhas F não são mais válidas para as novas condições. <br> <br> |
|  **PROFIPY**  |  *Software-Based Fault Injection*  | - Projetada para ser programável, permitindo aos usuários adicionar e personalizar um modelo de falhas de software. <br> <br>  - Os usuários podem especificar novos modelos de falhas de software usando uma linguagem específica de domínio (DSL) para injeção de falhas, sendo a especificação compilada em um injetor de falhas gerado automaticamente. <br> <br>  - O injetor de falhas gerado é aplicado ao software em teste para gerar versões com injeção de falhas e executar experimentos. <br> <br>  - É fornecido como software como serviço e inclui um fluxo de trabalho para configurar a carga de falha e a carga de trabalho para automatizar totalmente a execução de experimentos usando virtualização e paralelização baseadas em contêiner, e para executar análise de dados de falha. <br> <br>                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|   **VFIT**    | *Simulation-Based Fault Injection* | - É capaz de injetar falhas automaticamente aplicando a técnica de comandos do simulador. Também permite injetar falhas utilizando sabotadores e mutantes, mas neste caso o processo de injeção necessita da intervenção do usuário pois a inserção dos sabotadores e a geração de mutantes não são automáticas. <br> <br> - Pode injetar falhas permanentes, transitórias e intermitentes. <br> <br> - Um experimento de injeção é realizado em três fases: <br> <p> &nbsp;&nbsp;&nbsp; • Setup, onde são especificados os parâmetros do experimento. Esses parâmetros estão relacionados ao modelo (ou seja,  arquivo de carga de trabalho, duração da carga de trabalho, etc.), à injeção das falhas (ou seja, técnica de injeção, número de falhas, seleção do alvo da falha, duração da falha, modelos de falha, seleção do instante de injeção, etc.). ), e o tipo de análise a realizar (síndrome de erro ou validação de um Sistema Tolerante a Falhas). </p> <p> &nbsp;&nbsp;&nbsp; • Simulação. Aqui, o modelo é simulado na presença de falhas, gerando um golden run e uma série de traços de simulação de falhas.</p> <p> &nbsp;&nbsp;&nbsp; • Análise. Nesta fase, cada traço defeituoso é comparado com o golden run, extraindo diferentes medidas dependendo do tipo de análise selecionada. </p>                              |
|               |
